---
typora-root-url: ./

---

**计算机网络中的协议**

[TOC]

# 1.应用层协议

定义了运行在不同端系统上的应用程序进程如何相互传递报文。

应用层协议定义了：

![协议](/protocol/协议.png)

## 1.1 HTTP协议

HTTP协议是基于TCP/IP协议之上的应用层协议。

### 1.1.1 工作原理

当客户端输入一个URL后，HTTP协议就开始运作了。HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文。服务器以一个响应报文作为响应。

### 1.1.2 请求报文格式

#### 1.1.2.1 请求行(request line)

请求行遵循ASCII编码。

**字段：请求方法  URI  协议**

①GET：  GET  /books/?sex=man&name=Professional  HTTP/1.1 或 GET  /index.html  HTTP/1.1

用来获取/查询资源，请求访问指定服务器上的资源。直接在浏览器中键入网址搜索的方式，其请求方法就是GET，当浏览器请求一个对象时，在URL字段中会包含这个对象的标志，即GET请求的数据信息都在URL中，比如这个URI，books是访问服务器资源的路径，sex=man&name=Professional 是请求参数信息，即浏览器要访问的对象。这就是GET方法的一个缺点，请求参数全部暴露在URL中，不安全。而且URL长度有限，无法包含许多请求参数。

②POST： POST  /books/some  HTTP/1.1

用来提交表单。在form表单中，可以主动选择method为POST(当然也可以指定为GET)，一般POST不用来获取资源，而是向服务器提交/上传资源，比如提交用户数据验证登录用户、上传文件之类的。一般这些请求参数都放到请求体中。

③HEAD：HEAD  /index.html  HTTP/1.1

获得报文首部。和GET方法一样，只是HEAD只返回首部，即响应报文仅包含首部信息，HEAD一般是开发者用来进行调试跟踪，用于确认 URI 的有效性及资源更新的日期时间。

④PUT：PUT  /books/some  HTTP/1.1

用于上传对象到指定的Web服务器上的指定路径。

感觉和POST有点相似，百度查了一下，发现POST不具有幂等性，而PUT具有幂等性。所谓幂等性，即对同一URL的一次和多次请求某一个资源应该具有同样的副作用。当服务器上没有这个对象时，就创建这个对象，而当服务器上已经有这个对象时，就不会再次创建了，而是更新这个对象，所以在服务器上这个对象是唯一的。而非幂等性就是提交几次请求，就在服务器上创建几个相同的对象。

但是会产生安全问题，因为 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件。而POST方法，当请求的资源被加密(就拿登录一个淘宝网页来说)，服务器会返回401响应，浏览器会弹出一个对话框，要求浏览器提交用户名、密码，用户在输入身份验证信息后提交到服务器，服务器验证成功后用户才可以进入他自己账号下的淘宝。

⑤DELETE：用于删除指定服务器上的指定路径的资源，但由于HTTP1.1对于这个方法也不具有验证机制，任何人都可以删除服务器上的内容，因此此方法也被视为是不安全的，一般很少用。

#### 1.1.2.2 首部行(header line)

①HOST：www.baicu.com

表示请求对象所在的主机（在web高速缓存中有用）

②Connection：close

通知浏览器不使用持续连接，而是一个请求发送完之后就关闭这条连接。

> 补充：持续连接：HTTP中默认是持续连接，即Connection：keep-alive，服务器在发送完响应后保持该TCP的连接，在相同的客户和服务器之间，后序的请求和响应报文能通过相同的连接进行传送。  但如果一条连接一定时间没有使用就会自动断开。

③User-agent：Mozilla/5.0 

用户代理（即浏览器的类型）。

④Accept：text/html，application/xhtml+xml，image/webp

客户端可支持的数据类型（Content-Type），以MIME类型来表示。

⑤Accept-Language：zh-CN；en-US 

客户端可以支持的语言。

⑥Accept-Encoding：gzip，deflate

客户端支持的服务器对响应数据的编码格式。

⑦Content-Type：application/x-www-form-urlencoded

指定请求体的数据编码方式。

> application/x-www-form-urlencoded是form表单的默认编码方式，提交的数据按照 key1=val1&key2=val2 的方式进行编码，并放到请求体中。

⑧Content-Length：43

请求体的长度。

⑨Origin ：https://baidu.com

用于指明当前请求来自于哪个站点。

⑩Cookie：JSESSIONID=7BDD60BE24561687329E8DF0C63B0D

> 因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，服务器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以当浏览器第一次请求这个服务器时，为了识别用户，服务端给每个第一次登录的用户生成一个唯一标识(session_id)和session，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。
>
> 服务器生成一个session，并且将它保存在服务器上。*Session*对象存储特定用户会话所需的属性及配置信息。
>
> cookie的有效期：看浏览器的设置吧，大概也就是一个月左右。session的有效期：对于用户来说，session的有效期是在浏览器从打开到关闭，对于服务器来说，默认是30分钟session自动销毁，但可以设置。

#### 1.1.2.3 请求体(entity body)

GET方法没有请求体，其请求参数都在URL中，POST的请求参数在请求体中。

### 1.1.3 响应报文格式

#### 1.1.3.1 状态行(status line)

**字段**：协议  状态码

HTTP/1.1  200

#### 1.1.3.2 首部行(header line)

https://www.cnblogs.com/huey/p/4817586.html

> 内容编码：服务器在

#### 1.1.3.3 响应体(entity body)

### 1.1.4 历史版本



