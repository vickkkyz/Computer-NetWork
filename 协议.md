---
typora-root-url: ./
---

**计算机网络中的协议**

[TOC]

# 1.应用层协议

定义了运行在不同端系统上的应用程序进程如何相互传递报文。

应用层协议定义了：

![协议](/protocol/协议.png)

## 1.1 HTTP协议⭐

HTTP协议是基于TCP/IP协议之上的应用层协议。HTTP默认端口号为80。它也可以承载在TLS和SSL之上，通过加密、认证的方式实现数据传输的安全，称为HTTPS，HTTPS默认端口号为443。

### 1.1.1 工作原理

当客户端输入一个URL后，HTTP协议就开始运作了。HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文。服务器以一个响应报文作为响应。

### 1.1.2 请求报文格式

请求行和首部行编码为ASCII码。请求体根据header中的Content-Type规定body里采用什么编码。

#### 1.1.2.1 请求行(request line)

**字段：请求方法  URI  协议**

①GET：  GET  /books/?sex=man&name=Professional  HTTP/1.1 或 GET  /index.html  HTTP/1.1

用来获取/查询资源，请求访问指定服务器上的资源。直接在浏览器中键入网址搜索的方式，其请求方法就是GET，当浏览器请求一个对象时，在URL字段中会包含这个对象的标志，即GET请求的数据信息都在URL中，比如这个URI，books是访问服务器资源的路径，sex=man&name=Professional 是请求参数信息，即浏览器要访问的对象。这就是GET方法的一个缺点，请求参数全部暴露在URL中，不安全。而且URL长度有限，无法包含许多请求参数。

②POST： POST  /books/some  HTTP/1.1

用来提交表单。在form表单中，可以主动选择method为POST(当然也可以指定为GET)，一般POST不用来获取资源，而是向服务器提交/上传资源，比如提交用户数据验证登录用户、上传文件之类的。一般这些请求参数都放到请求体中。

③HEAD：HEAD  /index.html  HTTP/1.1

获得报文首部。和GET方法一样，只是HEAD只返回首部，即响应报文仅包含首部信息，HEAD一般是开发者用来进行调试跟踪，用于确认 URI 的有效性及资源更新的日期时间。

④PUT：PUT  /books/some  HTTP/1.1

用于上传对象到指定的Web服务器上的指定路径。

感觉和POST有点相似，百度查了一下，发现POST不具有幂等性，而PUT具有幂等性。所谓幂等性，即对同一URL的一次和多次请求某一个资源应该具有同样的副作用（指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的）。当服务器上没有这个对象时，就创建这个对象，而当服务器上已经有这个对象时，就不会再次创建了，而是更新这个对象，所以在服务器上这个对象是唯一的。而非幂等性就是提交几次请求，就在服务器上创建几个相同的对象。

但是会产生安全问题，因为 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件。而POST方法，当请求的资源被加密(就拿登录一个淘宝网页来说)，服务器会返回401响应，浏览器会弹出一个对话框，要求浏览器提交用户名、密码，用户在输入身份验证信息后提交到服务器，服务器验证成功后用户才可以进入他自己账号下的淘宝。

⑤DELETE：用于删除指定服务器上的指定路径的资源，但由于HTTP1.1对于这个方法也不具有验证机制，任何人都可以删除服务器上的内容，因此此方法也被视为是不安全的，一般很少用。

#### 1.1.2.2 首部行(header line)

①HOST：www.baicu.com

表示请求对象所在的主机（在web高速缓存中有用）

②Connection：close

通知浏览器不使用持续连接，而是一个请求发送完之后就关闭这条连接。

补充：持续连接：HTTP中默认是持续连接，即Connection：keep-alive，服务器在发送完响应后保持该TCP的连接，在相同的客户和服务器之间，后序的请求和响应报文能通过相同的连接进行传送。  但如果一条连接一定时间没有使用就会自动断开。

③User-agent：Mozilla/5.0 

用户代理（即浏览器的类型）。

④Accept：text/html，application/xhtml+xml，image/webp

客户端可支持的数据类型（Content-Type），以MIME类型来表示。

⑤Accept-Language：zh-CN；en-US 

客户端可以支持的语言。

⑥Accept-Encoding：gzip，deflate

客户端支持的服务器对响应数据的编码格式。

⑦Content-Type：application/x-www-form-urlencoded

指定请求体的数据编码方式。

application/x-www-form-urlencoded是form表单的默认编码方式，提交的数据按照 key1=val1&key2=val2 的方式进行编码，并放到请求体中。

⑧Content-Length：43

请求体的长度。

⑨Origin ：https://baidu.com

用于指明当前请求来自于哪个站点。

⑩Cookie：JSESSIONID=7BDD60BE24561687329E8DF0C63B0D

因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，服务器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以当浏览器第一次请求这个服务器时，为了识别用户，服务端给每个第一次登录的用户生成一个唯一标识(session_id)和session，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。

服务器生成一个session，并且将它保存在服务器上。*Session*对象存储特定用户会话所需的属性及配置信息。

cookie的有效期：看浏览器的设置吧，大概也就是一个月左右。session的有效期：对于用户来说，session的有效期是在浏览器从打开到关闭，对于服务器来说，默认是30分钟session自动销毁，但可以设置。

**Cookie 一般用来保存用户信息**。**Session 的主要作用就是通过服务端记录用户的状态**。

⑪If-Modified-Since：Web，9  Sep 2015 09:23:24

缓存的数据的有效时间，即它还没有更新。

这个是代理缓存服务器向真正的Web服务器发送的查询请求的首部行中有的。首先浏览器向代理服务器发送请求，代理服务器向Web服务器查询 存到代理服务器中的请求对象是否被改变，这个字段的内容是上次修改的时间。

#### 1.1.2.3 请求体(entity body)

(data...data..data...data...)

GET方法没有请求体，其请求参数都在URL中，POST的请求参数在请求体中。

### 1.1.3 响应报文格式

#### 1.1.3.1 状态行(status line)

**字段**：协议  状态码        HTTP/1.1  200

**状态码：**

200  OK：请求成功，信息在返回的响应报文中。

301 Moved Permanently ：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中，客户软件将自动获取新的URL。

400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。

404 Not Found：被请求的文档不在服务器上。

505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。

#### 1.1.3.2 首部行(header line)

①Last-Modified：数据的最后更新时间

一般是Web服务器为了响应代理缓存器而生成的首部行

②Connection：close

首部行告诉客户，发完这个HTTP响应就关闭这个tcp连接

还有一个情况就是 Connection：keep-alive  

​								keep-alive：timeout=20

③：Content-Encoding：gzip

内容编码：服务器在发送响应报文时，可以对响应体进行编码，这样减少了传输的资源大小，加快了传输速率，并且也相当于对数据进行了加密。

| 编码格式 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| gzip     | 表明实体采用 GNU zip 编码                                    |
| compress | 表明实体采用 Unix 的文件压缩程序                             |
| deflate  | 表明实体采用 zlib 的格式压缩                                 |
| identity | 表明没有对实体进行编码。当没有 Content-Encoding 首部是，就默认为这种情况 |

④Content-Length：40

如果消息体进行了内容编码，Content-Length 首部说明的就是编码后（encoded）的主体的字节长度，而不是未编码的原始主体长度。字节数。。这个字段的好处：知道报文什么时候全部到达。

⑤Transfer-Encoding：chunked

在HTTP/1.1中只有这一个值，表示分块传输。

> chunked编码使用若干个chunk串连而成，由一个标明长度为0的chunk标示结束。一个chunk块由头部和正文两部分组成，头部存的是这个块中正文部分（数据）的长度，CRLF，正文部分，CRLF。最后一个0的块的头部是0，CLRF，正文部分没有数据，CRLF。

> Transfer-Encoding和Content-Length是不会同时出现的。Content-Length如果服务器端计算出错的话(因为报文长度经常是不可预测)，假设Content-Length小于响应体的总长度，则传输会被截断，如果大于，则无法判定当前响应已经结束，会将请求持续挂起。为了解决这一问题，产生了Transfer-Encoding

⑥Server：Apache/2.2.3

表明该报文是由一台Apache Web服务器产生的

⑦Last-Modified：表明对象创建或最后修改的时间和日期

⑧Content-Type：text/html

说明实体体中的数据类型，以MIME规格定义的数据类型来表示。

![324](/image/324.png)

⑨Date：Tue，18 Aug 2015 15:44:04 GMT

表明服务器产生并发送这个响应报文的日期和时间。

#### 1.1.3.3 响应体(entity body)

(data...data..data...data...)

### 1.1.4 历史版本

#### 1.1.4.1 HTTP/1.0

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。即默认使用短连接。非持续连接

#### 1.1.4.2 HTTP/1.1

**1.长连接：**HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用持续连接Connection：keep-alive），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

> HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 ----javaguide
>

但是流水线方式，虽然客户端可以在没有接受到服务器的响应报文就发送下一个请求报文，但是在服务器端要求必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 。

> 若timeout时间内没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔一定时间发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。----谢希仁

**2.Host请求头字段：**（必须有）有时候一个服务器主机提供多个服务，比如假设www.baidu.com、  www.taobao.com 、www.jd.cm它们的服务器是同一个，那么这些域名对应的IP地址肯定是相同的，那我访问百度的网页，服务器怎么知道我访问的是百度呢？就通过host字段来区分。如果我们不传这个字段还会报一个400(bad request)的状态码

**3.新增了一些请求方法：**OPTIONS、PUT、DELETE、TRACE、CONNECT （也新增了一些头字段）

**4.新增了错误通知的状态码：**在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**5.缓存处理：**在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

#### 1.1.4.3 HTTP/2.0

**1.二进制分帧：**HTTP/1.x都是基于文本的，而HTTP/2.0是基于二进制六的。2.0引入了 帧（frame）和流（stream）。在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。http/2.0把HTTP消息分解为更小的独立的帧，然后可以交错着通过一个tcp连接发送给服务器，在服务器端通过帧中的标识，重新把帧还原为HTTP请求报文。

**2.多路复用：**由于HTTP/1.1的长连接会产生队头阻塞，因此发明了多路复用机制。就是交错发送。

下面是采用流水线方式的长连接和多路复用的区别。

![协议](/protocol/http2.0.png)

**3.头部数据压缩**：

在HTTP1.1中，HTTP请求和响应都是由请求行、首部行、请求体三部分组成。一般而言，请求体都会经过gzip压缩（根据首部行的Content-Encoding），或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。

在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。

**4.服务器推送（server push）：**

推送技术是指通过客户端与服务器端建立长链接，客户端可以接收由服务器端不定时发送的消息。服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。（服务器向额外推送的话，会发送一个PUSH_PROMISE帧，帧中包含预推送资源的首部，如果客户端响应，说明它需要这个资源，服务器则会发送一个Data帧，包含推送的数据）。

#### 1.1.4.4 HTTPS

-------留坑-------看到https再填--------

## 1.2 SMTP协议

使用TCP可靠传输服务。代理1对应的服务器1所在端口是25，代理2对应的服务器所在的端口是110

**工作原理：**用户代理1客户端向用户代理2客户端发送邮件，首先代理1会通过SMTP协议将邮件（其中携带着目的地的邮箱地址，即用户代理2对应的服务器）push给代理1对应的邮件服务器1，然后服务器1将邮件通过SMTP协议发送给代理2的邮件服务器，代理2通过POP3或IMAP协议从服务器2中pull邮件。

![324](/protocol/SMTP.jpg)

**SMTP协议与HTTP协议的区别：**

1. SMTP是一个推协议，即将数据推给接收方。HTTP是一个拉协议，从接收方获取数据。
2. SMTP的报文必须是按照标准ASCII码编码，而HTTP报文的实体体不需要用ASCII码编码，而是根据首部行的Content-Type来编码。
3. SMTP将所有报文对象放在一个报文中，HTTP则是一个对象封装一个报文。

## 1.3 DNS协议

DNS请求和响应报文使用UDP数据报经过端口53发送。

### 1.3.1 DNS层次结构

#### 1.3.1.1 根DNS服务器

根域：. 

根域名服务器中有一个根域名列表，里面记载着顶级域名和对应的TLD服务器的IP地址）。

#### 1.3.1.2 TLD(DNS)服务器

顶级域比如：com、cn、net、edu等等

TLD服务器管理着注册在该顶级域下的所有二级域的权威DNS服务器的IP地址，即它提供了权威DNS服务器的IP地址。

#### 1.3.1.3 权威DNS服务器

二级域比如：baidu.com、taobao.com、zzu.edu

权威DNS服务器管理着注册在该二级域下的所有三级/四级域的主机的IP地址。三/四级域有www.baidu.com、www.taobao.com、gaia.cs.umass.edu      **权威服务器下记录着主机的IP地址**

![协议](/protocol/层次结构.png)

#### 1.3.1.4 本地DNS服务器（不在DNS层次结构中）

这个DNS服务器地址是通过在主机的这个位置设置的，常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。当hosts文件中没有对应IP地址时，网络应用程序调用解析器（一段程序），解析器生成dns查询报文，通过协议栈将报文发送出去，这时发送的目的地就是主机上配置的dns服务器的地址。

自动获得DNS服务器地址：

这里分两种情况。1.你的电脑是直连运营商网络，即手机是4G网，电脑连接着手机的热点。这时候本地DNS服务器就是通过DHCP（系统）分配到的运营商的DNS服务器。2.你的电脑连接的是家里的WiFi，即通过路由器上网，这时候电脑如果想上网，需要先通过路由器，那么所有的DNS查询报文都会先经过路由器，然后再通过路由器向上层转发DNS报文。并且路由器执行DHCP服务，所以路由器就将它自己的IP地址分配给了主机的本地DNS服务器的IP地址。

![协议](/protocol/本地DNS.png)

### 1.3.2 DNS记录和报文和缓存

#### 1.3.2.1 资源记录（RR）

所有DNS服务器寻出了资源记录，这些记录提供了主机名到IP地址的映射。资源记录是一个包含了下列字段的4元组：  （Name，Value，Type，TTL），其中TTL是资源记录应当从缓存中删除的时间（资源记录的生存时间）。

| Type  | Name                        | Value                                                        |
| ----- | --------------------------- | ------------------------------------------------------------ |
| A     | 主机名（如www.baidu.com）   | 该主机名对应的IP地址（202.108.22.5）                         |
| NS    | 域（如com）                 | 权威DNS服务器的主机名（它知道如何获取该域中主机IP地址）（如baidu.com） |
| CHAME | 主机别名（如foo.com）       | 规范主机名（relay1.bar.foo.com）                             |
| MX    | 邮件服务器别名（如foo.com） | 规范主机名（mail.bar.foo.com）                               |

获取除了邮件服务器以外的服务器主机的别名，DNS客户应该请求一条CHAME记录。

> 对于Type=NS，如果这个DNS服务器上有一条这样的记录，那必定也有一条A记录，该记录提供了再NS记录的Value字段中的权威DNS服务器的IP地址。比如，本地DNS服务器向根DNS服务器发送一个查询报文，查询gaia.cs.umass.edu的IP地址，但是根DNS服务器中没有该主机名的一条A记录，但是它有一条NS记录，（umass.edu，dns.umass.edu，NS），即umass.edu域的权威DNS服务器的主机名是dns.umass.edu。然后还有一条A记录，（dns.umass.edu，192.168.167.91，A）, 即根DNS服务器指定 则本地DNS服务器去dns.umass.edu服务器中查到了umass.edu域的IP地址，再接着去umass.edu域DNS服务器查询是否有主机的记录。
>
> 其实也可能dns.umass.edu中没有gaia.cs.umass.edu的IP地址，但是它有一条NS记录：（cs.umass.edu，dns.cs.umass.edu，NS），然后还有一条A记录，（dns.cs.umass.edu，192.168.167.91，A），即它知道cs.umass.edu域的权威服务器dns.cs.umass.edu的IP地址，它觉得dns.cs.umass.edu可能知道gaia.cs.umass.edu的IP地址。然后本地DNS服务器再向dns.cs.umass.edu查询，最终找到了一条包含主机名的A记录。
>
> ---------------------摘自 《自顶向下》。因为感觉对这个查询过程有点迷，就摘了两段理解了一下。

#### 1.3.2.2 报文格式

![协议](/protocol/DNS报文.png)

#### 1.3.2.3 DNS缓存

首先是本地：**操作系统缓存**：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts

本地DNS服务器可以将之前收到的主机名到IP地址的映射缓存到它的本地存储器中，这样下次如果请求相同主机名的IP地址就直接查缓存就行了，缓存没有再进行迭代查询。

由于主机名和IP地址之间的映射不是永久的，所以DNS服务器在一段时间就将丢弃缓存的信息。

### 1.3.3 查询方式

递归查询和迭代查询。

区别：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。

可以从算法上面理解，做递归题时，⭐你永远要明白这个方法的作用并且相信它能完成这个任务⭐，所以你在第一层，向得到后面层的结果，就直接调用这个方法，相信它一定给你预期的完成结果，然后你仅仅拿到返回值之后再进行return或者什么操作就行了。对于DNS查询也是这样，第一层是请求主机去问本地DNS服务器，请求主机不管本地DNS服务器怎么操作，请求主机就相信本地DNS服务器一定能交给它那个IP地址，请求主机很省心。

对于迭代，就是需要自己通过一遍遍的运算，一步步找结果。即本地DNS服务器一个一个的去查IP地址，先查根DNS服务器，查到一个相关的结果，再去另一个地方查。

### 1.3.4 负载均衡

当一个Web站点有冗余web服务器时（即同一个域名对应多个IP地址，这样做的目的是减小一个web服务器的访问负担），此时如果一个主机请求该站点的IP地址，DNS服务器会返回这个IP地址集合，但在每次的响应中循环这些地址的次序（轮询），因为客户端总是向IP地址排在最前面的服务器发送http请求报文。

但是轮询是有缺点的，如果某一个服务器出现故障，DNS服务器可不知道，会按照原样返回一定顺序的IP地址集合。所以这时候加入了负载均衡器，将该站点域名映射到负载均衡器上，DNS服务器只返回负载均衡器的IP地址，由负载均衡器来判断应该转发请求到哪个Web服务器上。

### 1.3.5 DNS污染

https://www.zhihu.com/search?type=content&q=DNS%E6%B1%A1%E6%9F%93%E5%92%8CDNS%E5%8A%AB%E6%8C%81

### 1.3.6 美国人如果把根域名服务器封了，中国会从网络上消失吗❓ 

https://zhuanlan.zhihu.com/p/185674120