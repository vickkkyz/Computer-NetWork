---
typora-root-url: ./
---

**计算机网络中的协议**

[TOC]

# 1.应用层协议

定义了运行在不同端系统上的应用程序进程如何相互传递报文。

应用层协议定义了：

![协议](/protocol/协议.png)

## 1.1 HTTP协议

HTTP协议是基于TCP/IP协议之上的应用层协议。HTTP默认端口号为80。它也可以承载在TLS和SSL之上，通过加密、认证的方式实现数据传输的安全，称为HTTPS，HTTPS默认端口号为443。

### 1.1.1 工作原理

当客户端输入一个URL后，HTTP协议就开始运作了。HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文。服务器以一个响应报文作为响应。

### 1.1.2 请求报文格式

请求行和首部行遵循ASCII编码。请求体根据header中的Content-Type规定body里采用什么编码。

#### 1.1.2.1 请求行(request line)

**字段：请求方法  URI  协议**

①GET：  GET  /books/?sex=man&name=Professional  HTTP/1.1 或 GET  /index.html  HTTP/1.1

用来获取/查询资源，请求访问指定服务器上的资源。直接在浏览器中键入网址搜索的方式，其请求方法就是GET，当浏览器请求一个对象时，在URL字段中会包含这个对象的标志，即GET请求的数据信息都在URL中，比如这个URI，books是访问服务器资源的路径，sex=man&name=Professional 是请求参数信息，即浏览器要访问的对象。这就是GET方法的一个缺点，请求参数全部暴露在URL中，不安全。而且URL长度有限，无法包含许多请求参数。

②POST： POST  /books/some  HTTP/1.1

用来提交表单。在form表单中，可以主动选择method为POST(当然也可以指定为GET)，一般POST不用来获取资源，而是向服务器提交/上传资源，比如提交用户数据验证登录用户、上传文件之类的。一般这些请求参数都放到请求体中。

③HEAD：HEAD  /index.html  HTTP/1.1

获得报文首部。和GET方法一样，只是HEAD只返回首部，即响应报文仅包含首部信息，HEAD一般是开发者用来进行调试跟踪，用于确认 URI 的有效性及资源更新的日期时间。

④PUT：PUT  /books/some  HTTP/1.1

用于上传对象到指定的Web服务器上的指定路径。

感觉和POST有点相似，百度查了一下，发现POST不具有幂等性，而PUT具有幂等性。所谓幂等性，即对同一URL的一次和多次请求某一个资源应该具有同样的副作用（指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的）。当服务器上没有这个对象时，就创建这个对象，而当服务器上已经有这个对象时，就不会再次创建了，而是更新这个对象，所以在服务器上这个对象是唯一的。而非幂等性就是提交几次请求，就在服务器上创建几个相同的对象。

但是会产生安全问题，因为 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件。而POST方法，当请求的资源被加密(就拿登录一个淘宝网页来说)，服务器会返回401响应，浏览器会弹出一个对话框，要求浏览器提交用户名、密码，用户在输入身份验证信息后提交到服务器，服务器验证成功后用户才可以进入他自己账号下的淘宝。

⑤DELETE：用于删除指定服务器上的指定路径的资源，但由于HTTP1.1对于这个方法也不具有验证机制，任何人都可以删除服务器上的内容，因此此方法也被视为是不安全的，一般很少用。

#### 1.1.2.2 首部行(header line)

①HOST：www.baicu.com

表示请求对象所在的主机（在web高速缓存中有用）

②Connection：close

通知浏览器不使用持续连接，而是一个请求发送完之后就关闭这条连接。

> 补充：持续连接：HTTP中默认是持续连接，即Connection：keep-alive，服务器在发送完响应后保持该TCP的连接，在相同的客户和服务器之间，后序的请求和响应报文能通过相同的连接进行传送。  但如果一条连接一定时间没有使用就会自动断开。

③User-agent：Mozilla/5.0 

用户代理（即浏览器的类型）。

④Accept：text/html，application/xhtml+xml，image/webp

客户端可支持的数据类型（Content-Type），以MIME类型来表示。

⑤Accept-Language：zh-CN；en-US 

客户端可以支持的语言。

⑥Accept-Encoding：gzip，deflate

客户端支持的服务器对响应数据的编码格式。

⑦Content-Type：application/x-www-form-urlencoded

指定请求体的数据编码方式。

> application/x-www-form-urlencoded是form表单的默认编码方式，提交的数据按照 key1=val1&key2=val2 的方式进行编码，并放到请求体中。

⑧Content-Length：43

请求体的长度。

⑨Origin ：https://baidu.com

用于指明当前请求来自于哪个站点。

⑩Cookie：JSESSIONID=7BDD60BE24561687329E8DF0C63B0D

> 因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，服务器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以当浏览器第一次请求这个服务器时，为了识别用户，服务端给每个第一次登录的用户生成一个唯一标识(session_id)和session，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。
>
> 服务器生成一个session，并且将它保存在服务器上。*Session*对象存储特定用户会话所需的属性及配置信息。
>
> cookie的有效期：看浏览器的设置吧，大概也就是一个月左右。session的有效期：对于用户来说，session的有效期是在浏览器从打开到关闭，对于服务器来说，默认是30分钟session自动销毁，但可以设置。
>
> **Cookie 一般用来保存用户信息**。**Session 的主要作用就是通过服务端记录用户的状态**。

⑪If-Modified-Since：Web，9  Sep 2015 09:23:24

缓存的数据的有效时间，即它还没有更新。

> 这个是代理缓存服务器向真正的Web服务器发送的查询请求的首部行中有的。首先浏览器向代理服务器发送请求，代理服务器向Web服务器查询 存到代理服务器中的请求对象是否被改变，这个字段的内容是上次修改的时间。

#### 1.1.2.3 请求体(entity body)

(data...data..data...data...)

GET方法没有请求体，其请求参数都在URL中，POST的请求参数在请求体中。

### 1.1.3 响应报文格式

#### 1.1.3.1 状态行(status line)

**字段**：协议  状态码        HTTP/1.1  200

**状态码：**

200  OK：请求成功，信息在返回的响应报文中。

301 Moved Permanently ：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中，客户软件将自动获取新的URL。

400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。

404 Not Found：被请求的文档不在服务器上。

505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。

#### 1.1.3.2 首部行(header line)

①Last-Modified：数据的最后更新时间

> 一般是Web服务器为了响应代理缓存器而生成的首部行

②Connection：close

首部行告诉客户，发完这个HTTP响应就关闭这个tcp连接

还有一个情况就是 Connection：keep-alive  

​								keep-alive：timeout=20

③：Content-Encoding：gzip

> 内容编码：服务器在发送响应报文时，可以对响应体进行编码，这样减少了传输的资源大小，加快了传输速率，并且也相当于对数据进行了加密。

| 编码格式 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| gzip     | 表明实体采用 GNU zip 编码                                    |
| compress | 表明实体采用 Unix 的文件压缩程序                             |
| deflate  | 表明实体采用 zlib 的格式压缩                                 |
| identity | 表明没有对实体进行编码。当没有 Content-Encoding 首部是，就默认为这种情况 |

④Content-Length：40

如果消息体进行了内容编码，Content-Length 首部说明的就是编码后（encoded）的主体的字节长度，而不是未编码的原始主体长度。字节数。。这个字段的好处：知道报文什么时候全部到达。

⑤Transfer-Encoding：chunked

在HTTP/1.1中只有这一个值，表示分块传输。

> chunked编码使用若干个chunk串连而成，由一个标明长度为0的chunk标示结束。一个chunk块由头部和正文两部分组成，头部存的是这个块中正文部分（数据）的长度，CRLF，正文部分，CRLF。最后一个0的块的头部是0，CLRF，正文部分没有数据，CRLF。

> Transfer-Encoding和Content-Length是不会同时出现的。Content-Length如果服务器端计算出错的话(因为报文长度经常是不可预测)，假设Content-Length小于响应体的总长度，则传输会被截断，如果大于，则无法判定当前响应已经结束，会将请求持续挂起。为了解决这一问题，产生了Transfer-Encoding

⑥Server：Apache/2.2.3

表明该报文是由一台Apache Web服务器产生的

⑦Last-Modified：表明对象创建或最后修改的时间和日期

⑧Content-Type：text/html

说明实体体中的数据类型，以MIME规格定义的数据类型来表示。

![324](/image/324.png)

⑨Date：Tue，18 Aug 2015 15:44:04 GMT

表明服务器产生并发送这个响应报文的日期和时间。

#### 1.1.3.3 响应体(entity body)

(data...data..data...data...)

### 1.1.4 历史版本

#### 1.1.4.1 HTTP/1.0

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。即默认使用短连接。非持续连接

#### 1.1.4.2 HTTP/1.1

**1.长连接：**HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用持续连接Connection：keep-alive），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

*HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 ----javaguide*

但是流水线方式，虽然客户端可以在没有接受到服务器的响应报文就发送下一个请求报文，但是在服务器端要求必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 。

*若timeout时间内没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔一定时间发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。----谢希仁*

**2.Host请求头字段：**（必须有）有时候一个服务器主机提供多个服务，比如假设www.baidu.com、  www.taobao.com 、www.jd.cm它们的服务器是同一个，那么这些域名对应的IP地址肯定是相同的，那我访问百度的网页，服务器怎么知道我访问的是百度呢？就通过host字段来区分。如果我们不传这个字段还会报一个400(bad request)的状态码

**3.新增了一些请求方法：**OPTIONS、PUT、DELETE、TRACE、CONNECT （也新增了一些头字段）

**4.新增了错误通知的状态码：**在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**5.缓存处理：**在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

#### 1.1.4.3 HTTP/2.0

**1.二进制分帧：**HTTP/1.x都是基于文本的，而HTTP/2.0是基于二进制六的。2.0引入了 帧（frame）和流（stream）。在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。http/2.0把HTTP消息分解为更小的独立的帧，然后可以交错着通过一个tcp连接发送给服务器，在服务器端通过帧中的标识，重新把帧还原为HTTP请求报文。

**2.多路复用：**由于HTTP/1.1的长连接会产生队头阻塞，因此发明了多路复用机制。就是交错发送。

下面是采用流水线方式的长连接和多路复用的区别。

![协议](/protocol/http2.0.png)

**3.头部数据压缩**：

在HTTP1.1中，HTTP请求和响应都是由请求行、首部行、请求体三部分组成。一般而言，请求体都会经过gzip压缩（根据首部行的Content-Encoding），或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。

在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。

**4.服务器推送（server push）：**

推送技术是指通过客户端与服务器端建立长链接，客户端可以接收由服务器端不定时发送的消息。服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。（服务器向额外推送的话，会发送一个PUSH_PROMISE帧，帧中包含预推送资源的首部，如果客户端响应，说明它需要这个资源，服务器则会发送一个Data帧，包含推送的数据）。

#### 1.1.4.4 HTTPS

-------留坑-------看到https再填--------