---
typora-root-url: ./
---

**网络是怎样连接的**

[TOC]



![11](/image/11.png)

# 1.浏览器生成HTTP消息

## 1.1 浏览器解析URL

<u>URL</u>

> *URL的组成   协议://用户名:密码@服务器域名/文件路径名*
>
> *协议：http/ftp/file*
>
> *用户名和密码：指定用户名或密码作为从服务器端获取资源时必要的登录信息，是可省略的。*
>
> *服务器域名：web ftp服务器域名，本机的话是localhost(对应的IP是127.0.0.1)*
>
> *文件路径名：*如/dir1/a.html

如果遇到这种URL（省略文件名）：

http://baidu.com/ 和 http://baidu.com  -------> 即http://baidu.com/index.html

http://baidu.com/dir/  -------> 即http://baidu.com/dir/index.html

http://baidu.com/dir   -------> 即 先判断web服务器上是否有文件dir，在判断是否有目录dir 



## 1.2 HTTP1.1请求消息

<u>HTTP协议</u>

HTTP方法：虽然有这么多，但是经常用的只有前两个，因为比如put delete 方法不安全，因此最多只在公司内网中使用。

> **注意：通过浏览器的地址栏输入地址，所访问的URL都是get请求**
>
> **一. 浏览器会发送get请求的情况**
>
> 1. 直接在浏览器地址栏输入某个地址
> 2. 点击链接
> 3. 表单默认的提交方式
>
> **二.浏览器会发送post请求的情况**
>
> 1. 设置表单method = “post”

浏览器将URL解析出来的数据填写在请求消息（请求行、消息头、消息体）中对应的内容上

![12](/image/12.png)

**消息头字段类型**

![17](/image/17.png)

<img src="/image/18.png" alt="18"  />

![19](/image/19.png)

## 1.3 HTTP1.1响应消息

包括状态行、消息头、消息体

状态码：1XX——告知浏览器请求的处理进度和情况，主要是临时的响应

​				2XX——表明请求被正常处理了

​				3XX——表明浏览器需要执行进一步操作以正确处理请求

​				4XX——表明客户端发生错误

​				5XX——服务器发生错误

<u>HTTP1.1</u>：头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制(图片)

在keep-alive中，虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。比如请求网页资源，而一个网页上包含多个图片资源，则浏览器会先给图片预留空间，然后再次发送http请求，获取图片资源。

<u>HTTP2.0</u>：二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧

1.多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。

2.对于消息头，采用头信息压缩机制。对于相同的头部，不必再通过请求发送，只需发送一次。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。加快传输速率。

3.在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了HTTPS.

**-----------------------------TSL协议----------------------**



# 2.发送HTTP请求前的准备

如果要想服务器发送请求，必须知道它的IP地址才可以发送，因此现在浏览器要向DNS服务器查询服务器的IP地址

## 2.1 查询服务器的IP地址

浏览器调用**解析器**，生成向**DNS服务器**发送查询的请求，解析器再调用os的协议栈向DNS服务器发送这个查询请求，查到后，DNS服务器发送IP地址给协议栈，协议栈在返回到解析器，解析器将IP地址存放到浏览器的指定内存中

### 2.1.1 解析器

**定义：**解析器实际上是一段应用程序（程序名为gethostbyname(String  要查询的域名)），包含在OS的Socket库中。

**工作原理：** <内存空间> = gethostbyname( 要查询的域名)

​														`↓`（解析器只负责生成  发送给DNS服务器的查询消息）

​											委托协议栈发送查询消息

​														`↓`

​													  网卡

​														`↓`

​												DNS服务器（本机上配置的那个DNS服务器）

​														`↓`

​												匹配到域名对应的DNS服务器，并查询到IP地址

​														`↓`

​				将IP地址返回给协议栈，协议栈返回给函数体中的接收DNS服务器返回的响应消息

​														`↓`

​						解析器将IP地址存放到浏览器的指定内存中



<u>hosts文件：当用户在浏览器中输入一个url时，协议栈会首先自动从hosts文件中寻找对应的IP地址，如果找到了，就将IP地址给解析器，如果没有找到，则协议栈会将域名提交给DNS域名解析服务器进行IP地址的解析。</u>   比如  本地域名和IP的映射

![33](/image/33.png)

### 2.1.2 DNS服务器

**来自客户端的查询消息包括：**域名、Class、记录类型

Class：用来识别网络的信息。现在都是互联网，因此Class=IN

记录类型：表示域名对应为什么记录。A表示域名对应的是IP地址，MX表示域名对应的是邮件服务器

**域名的层次结构**

www.baidu.com.         ------>        域名最后面的点 就表示根域。com为一级域。baidu为二级域。www为服务器的名字，大多数Web服务器都采用www这样的名字，只是惯例

*根域的DNS服务器的相关信息已经包含在DNS服务器程序的配置文件中了*

*DNS服务器可以将之前查询过的域名缓存下来（超过一个规定的有效期就会被删除）*

本地DNS服务器->根DNS服务器->TLD(顶级域) DNS服务器->权威DNS服务器

# 3.将网络包通过网卡发送出去

获得了服务器的IP地址之后，就可以发送HTTP消息了。

## 3.1  创建套接字

协议栈的内部结构：

![61](/image/61.png)

### 3.1.1 套接字是什么

套接字是一个概念，它是对 <u>在协议栈内部用于存放控制信息的内存空间</u> 的一个泛称。

在这个内存空间中存着一张表，每创建一个套接字，就在这张表中增加一行信息，一行就代表一个套接字。简单来说，套接字就是IP+端口。

套接字是成对出现的，且每个连接有唯一的一堆套接字。

**套接字描述符**是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。因此根据套接字描述符就可以找到其对应的套接字数据结构。

### 3.1.2 为什么要创建套接字

协议栈在执行收发数据的操作时，需要参考套接字中的信息。比如发送过数据之后，长时间没收到相应信息，这时就需要重新参考套接字中的IP地址，重新发送数据包。

### 3.1.3 创建过程

应用程序调用Socket库的socket函数，这里传入使用的是TCP还是UDP连接。然后调用协议栈，协议栈会分配一个套接字的内存空间，并写入初始状态。返回到socket函数中，该函数返回给应用程序一个套接字描述符，来标识唯一的套接字。

## 3.2 连接服务器

客户端套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。

服务端一般会在系统启动的时候就创建套接字并等待客户端连接。

### 3.2.1 TCP头部

![71](/image/71.png)



### 3.2.2 连接

应用程序调用Socket库的connect函数，connect(<描述符>，<服务器IP地址和端口号>，...)，这些信息传递给协议栈中的TCP模块，在TCP模块中创建TCP头部，有了服务器的IP地址和端口号，客户端套接字就知道要连接哪个套接字了。

**--------------------------三次握手-------------------------**

**客户端：**发送TCP连接包给服务器。167

**服务器端：**接收到包，TCP头部的控制位SYN=1说明是连接包，则TCP模块会检查接收方指定的端口号上是否有等待连接的套接字，如果有，则为这个套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值（序号表示是从第几个字节开始发送的）、窗口大小（发送方一次发送多少字节）信息写入进去，并分配发送缓冲区send buffer和接收缓冲区recv buffer的内存空间，然后生成确认号ACK，窗口大小（接受缓冲区的大小），用这些信息生成一个新的TCP头部，发送给客户端。

**客户端：**收到这个包后，客户端会返回一个表示接收确认的ACK号。

连接成功后，协议栈会向套接字中写入服务器端的IP地址和端口号，将对应状态改为连接完毕。



## 3.3 发送数据

### 3.3.1 将HTTP请求放入协议栈的缓冲区

TCP协议栈维护着两个socket缓冲区：send buffer和recv buffer。要通过TCP连接发送出去的数据都先拷贝到send buffer，即将http消息写入协议栈的缓冲区中。

TCP发送缓存

协议栈不是一收到数据就马上发给其中的TCP模块。(但如果一个网络包的长度就超过MSS的话，会将其进行以MSS长度单位进行拆分在再发送)

两个判断要素：1. MTU 一个网络包的最大长度（包含头部的总长度）

​									MSS 一个网络包中能容纳的最大数据长度 = MTU - 头部

​									即缓冲区中的数据长度超过或接近MSS，再将数据发送出去。

​							2. 时间。

​							协议栈内部有一个计时器，等到一定时间如果还没有满足MSS就会直接发送数据包。



### 3.3.2 加上TCP、IP和MAC头部

缓冲区将数据发送给协议栈的TCP模块，在其中加上TCP头部

（TCP报文段）-> 现在来说说IP模块。IP模块生成IP头部和MAC头部

**生成包含接收方IP地址的IP头部**

![103](/image/103.png)

**接收方IP字段：**直接查询套接字中记录的目的IP地址即可。

//前面调用connect组件进行套接字连接的时候，就已经将服务器IP地址写入套接字中了。

**发送方IP字段：**填写当前计算机中的网卡的IP地址。

我们可以显而易见的知道每块网卡的MAC地址，这时候选择哪个网卡来发送数据包呢？需要根据接收方的IP地址，使用**路由表**，选择一个合适的目的路由器，并找到对应的IP地址。

路由表：![105](/image/105.png)



**生成以太网用的MAC头部**

![107](/image/107.png)

**接收方MAC地址：**上方我们已经知道接收方（路由器）的IP地址，然后查询ARP缓存，如果其中有接收方的MAC地址，就直接使用该地址，如果没有，需要通过**ARP协议**（在同一个子网中）广播查询目标路由器的MAC地址。缓存中的值在一定时间内会被删除。

**发送方MAC地址：**网卡的MAC地址



### 3.3.3 将数据包发给网卡

![115](/image/115.png)

网卡的作用：将IP包（数字信息）转换成电或光信号发送出去

**网卡初始化：**打开计算机启动OS时，网卡驱动程序会对硬件进行初始化操作，然后硬件才可以进入可使用的状态。

数据包首先存放到缓冲区中，接着发送给**MAC模块**，然后发送给**PHY模块**

**MAC模块：**将数据包的头部加上报头和起始帧分界符，尾部加上FCS帧校验序列。

<u>0和1两种比特分别对应特定的电压和电流，因此就将可以数字信号转换为了电信号。</u>

报头是一串101010....这样0和1交替的比特序列，因为信号是由 数据信号和时钟信号叠加形成的，因此它的作用是测量时钟信号的特殊信号，以便服务端可以根据报头来筛出数据信号。起始帧分界符标识包的起始位置。

**PHY模块：**将数字信号转换为模拟信号（电信号）。并通过网线发送出去

### 3.3.4 开始发送数据

发送数据，直到服务器接收缓冲区剩余空间为0，同时接收方也会取出数据，并发送数据包，其中 tcp头部，更新窗口大小以及ACK号。

![94](/image/94.png)



# 4.信号通过集线器、交换机到达互联网接入网

![140](/image/140.png)

为了防止信号衰减，局域网中的网线采用双绞线。

## 4.1 集线器

信号到达集线器后，会被广播到整个网络。（按照以太网的基本架构）

![142](/image/142.png)

![143](/image/143.png)

信号到达RJ-45接口后，接着就到达集线器的PHY模块了，会进入中继电路，中继电路会将接受的信号广播到集线器的所有端口上，因此信号从所有端口流出，到达连接在集线器上的所有设备，然后这些设备会根据MAC头部的接收方MAC地址判断信号是否是发给自己的，如果是则接受，反之丢弃。

<u>接收信号的设备可以使交换机、路由器、服务器等。</u>

## 4.2 交换机

![150](/image/150.png)

交换机的一个端口就相当于计算机的一个网卡，只是没有MAC地址。

**MAC地址表：**主要包含两个字段，一个是发送方的MAC地址，另一个是该发送设备连接在交换机的哪个端口上。“发送方”即将信号发送给交换机的那个设备。

**MAC地址表的维护：**1.当交换机收到包时，就会将该发送方设备的MAC地址、以及连接在交换机的端口号写入到地址表中。这样下次当交换机收到发往这个地址的包时，就可以将它转发到正确的端口。2.有时候也会删除地址表中的一段时间都不使用的某条记录。**防止设备移动时产生问题。？？？**

**过程：**信号到达网线接口RJ-45后，由PHY模块进行接收，PHY模块将电信号转换为数字信息，再传递给MAC模块，通过FCS检测如果没有出错则将包放到缓冲区中。然后需要通过交换机的MAC表来确认包转发给哪个端口，即查询包的接收方MAC地址//**（下一跳路由的MAC地址）**是否已经在MAC地址表中有记录。如果查询到了，( 根据以太网规则，需要先确认信号收发模块没有信号进来。但是现在交换机都是全双工模式，可以不判断了) 就将包的数字信息转换为电信号，发送出去。如果没有查询到，只能将包混发到除了源端口以外的所有端口上，只要有设备响应，返回响应包，交换机就进行MAC地址表的维护工作。

## 4.3 路由器

![160](/image/160.png)

**路由器：**基于IP设计的。包括端口模块和转发模块。

**端口模块：**结构和网卡基本相同，都有RJ-45接口，PHY模块，MAC模块。因此路由器的端口也具有MAC地址。

**转发模块：**根据路由表的记录来确定转发目标。路由表根据IP头部的IP地址来确定转发目标。路由表会根据子网掩码的情况，忽略主机号，只匹配目标地址的网络号部分。

接口表示将包通过接口列中指定的路由器网络接口，即端口来进行转发。

<u>网关</u>表示将包转发到网关列中指定的IP地址（下一跳路由器的地址），如果网关列内容为空时，则IP头中的接收方IP地址就是要转发的目标地址。

<u>跃点</u>数表示距离目标IP地址的距离远近，如果多个目标地址都可以的话，会优先选择跃点数小的进行转发。

**路由器的功能：**路由器的地址转换；包过滤

路由器的地址转换：解决IP地址不足的问题。

ISP将一些地址作为私有地址（这些地址是固定的，且一般可重复）。在私有地址的用户向互联网发起请求时，数据包先流入路由器，路由器中含有地址转换的模块；地址转换模块管理着地址转换表，通过表里面预先设定的记录 会将含有私有地址的数据包的IP头部中的发送方IP地址转为设定的公有地址，在将数据包传输到以太网中。

![179](/image/179.png)

接收互联网的响应和发送正好相反；公有地址路由器通过收到响应数据的端口来确定数据是发给哪个私有地址，通过地址转换模块将包IP转为私有地址IP进而来发送响应数据

**路由表：**

![163](/image/163.png)

**过程：**首先，路由器将委托端口的硬件将包接收进来，这一步选择哪个端口接收取决于信号是遵守哪个规范，如果是按照以太网规范进行工作的，就用以太网端口进行接收。

信号到达网线接口，将其传给PHY模块，MAC模块，将信号转换为数字信息，然后根据FCS进行错误校验，然后<u>检查接收方MAC地址是否与路由器端口的MAC地址一致</u>（这里其实在交换机处已经校验过了，再次校验的原因是，如果交换机的MAC表中没有找到对应的MAC地址，它将会把包转发到所有除源端口以外的端口，这时路由器就需要再校验一遍是不是发给自己的包），一致则接收，否则丢弃。

当包到达路由器时，MAC头就会被丢弃。然后通过转发模块的路由表选择下一个转发目标的IP地址，然后根据ARP协议查询它的MAC地址，作为接收方MAC地址，发送方MAC地址就是输出端口的MAC地址，然后写入新的MAC头部中。

然后通过路由表指定的输出端口发送包。不同的网络传输协议可能不同，输出端口所能允许的包长度也不一样，因此有时候需要将包分片，TCP头部和数据部分视作一整个数据包进行切分；根据协议允许的最大传输长度MTU。

如果路由表中找不到匹配路由时选择默认路由（默认网关），即子网掩码为0.0.0.0  这个值在Windows里面可以直接设置。

**注：**IP（路由器）负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程是由以太网（交换机）来负责的。这里主要看输出端口的类型，此时输出端口为以太网。

# 5.通过接入网到达互联网内部

接入网，就是指连接互联网与家庭、公司网络的通信线路。一般家用的接入网方式包括ADSL、FTTH、电话线、CATV、ISDN，公司还可能使用专线。

**接入网的整体结构：**ADSL和FTTH

![194](/image/194.png)



![完整214](/image/214.png)

## 5.1 ADSL接入网

ADSL：不对称数字用户线，利用电话线将用户接入互联网的一种技术。即采用与电话线共用的线路的方式，避免额外接线的方式。

### 5.1.1 网络包来到互联网接入路由器

互联网接入路由器：将私有地址转换成公有地址。

因为使用路由器上网，BAS下发的参数就会被配置到路由器上，即分配的公有的IP地址也是给路由器。那么计算机会被分配一个私有地址，当向网络发送包时，会先通过路由器将发送方的私有地址转化为公有地址。

> 计算机被分配一个私有地址，这样说不准确。IP地址其实是分配给计算机上的网卡的。可以在设置窗口中设置IP地址，也可以通过DHCP服务器自动分配IP地址。分配的IP地址会保存在计算机中。

![200](/image/200.png)

### 5.1.2 接入路由器将包发给ADSL Modem

互联网接入路由器和ADSL Modem之间是通过以太网连接的，因此会按照以太网的规则来发送包。

**过程：**互联网接入路由器接收到包后，将MAC头部去掉，并在IP头部前面加上MAC、PPPoE、PPP头部，然后发送给ADSL Modem。MAC头部和PPPoE头部的作用是将包送达BAS的接口。

### 5.1.3 ADSL Modem将ADSL信号发给分离器

> **ADSL Modem：**ADSL调制解调器。由调制器和解调器两部分组成，调制器是把计算机的数字信号调制成可在电话线上传输的电信号的装置，在接收端，解调器再把电信号转换成计算机能接收的数字信号。

**过程：**ADSL接收到包后，将包拆分成ATM信元，然后通过调制将信元转换成电信号，发送给分离器。

<u>为什么拆分成ATM信元而不是其他格式的呢？</u>原因是许多通信运营商最开始传输数据是通过ATM技术实现的，这种技术传的就是信元，为了避免数据包与其他设备要求传输的类型不同，就直接按照ATM信元来传输了。

### 5.1.4 分离器将ADSL信号发给DSLAM

**分离器：**因为网络信号与电话信号都使用了电话线进行传输，所以需要在用户终端和接入互联网部分将二者分离，所以引入了分离器，根据两者信号频率的不同实现了信号的分离。将一定频率以上的信号过滤掉，即过滤掉ADSL使用的高频信号，这样当接收信号时，电话信号会传入电话机，而ADSL信号则传入ADSL Modem中。分离器也有逆向的合并功能，即将电话来的低频的语音信号和ADSL来的高频数据信号频率合并成一个信号通过电话线逆向地发送。

> 第一个分离器：将电话信号和ADSL信号汇合在一起，发送出去。
>
> 第二个分离器：将电话信号和ADSL信号根据不同频率分离，电话信号就发送给电话交换机，进而发送给电话网，ADSL信号发送给DSLAM。

**过程：**第一个分离器将电话信号和ADSL信号汇合在一起，发送出去。进入用户端电话局，内部：通过配线盘，发送给第二个分离器，它将ADSL信号（电信号）分离出来，发送给DSLAM。

### 5.1.5 DSLAM将ADSL信号发送给BAS

**DSLAM：**将多个ADSL Modem整合在一个外壳里的设备。具有ATM接口，可以接收ATM信元，也可以将收到的ATM信元还原成原始的包。

**过程：**DSLAM通过读取信号波形，根据振幅和相位判断对应的比特值，将电信号还原为数字信息---信元，通过ATM交换机发送给BAS。

### 5.1.6 BAS通过隧道将网络包发给网络运营商

**BAS：**宽带接入服务器，其实它是一种路由器，具有ATM接口，可以接收ATM信元。即运营商的进化型路由器，他们一般把它安装在电话局中。

**BAS的功能：**

- **用户认证和配置下发。**

  **用户认证：**ADSL和FTTH接入网中都需要先输入用户名和密码，登录之后才能访问互联网，BAS是登录操作的窗口。BAS使用PPPoE方式实现这个功能。客户端将密码发给BAS的过程，可以采用将密码加密的CHAP方式，或者采用不加密的PAP方式。但一般采用CHAP方式。

  <u>PPPoE：</u>因为ADSL和FTTH不能像拨号接入上网那样采用HDLC协议作为容器来传输PPP消息，因此他们用以太网包来装载PPP消息，这一规格就称为PPPoE。

  ![220](/image/220.png)

  ![221](/image/221.png)

  

  **FTTH中的PPP：**

  ![222](/image/222.png)

  ![231](/image/231.png)

  

  **配置下发：**在校验密码后，BAS向用户下发TCP/IP配置信息。这里下发的配置信息包括分配给上网设备的IP地址、DNS服务器的IP地址以及<u>默认网关的IP地址</u>。BAS下发的信息会被配置到互联网接入路由器的BAS端的端口上，这样路由器就完成接入互联网的准备了。

  默认路由：当路由表中没有匹配到其他路由时，网络包就会被转发到这个默认路由上。

  如果接收方的IP地址在互联网接入路由器中没有找到，则将其转发给BAS下发的默认路由，这个转发是按照PPPoE规则进行的，即要转发的包加上MAC、PPPoE、PPP头部。MAC头部中，接收方MAC地址是通过PPPoE的发现机制查询的BAS的MAC地址，发送方MAC地址是互联网接入路由器的BAS端的端口的MAC地址。

  **//转发给默认路由 默认网关（路由器的地址）知道，通过ARP查询它的MAC地址，所以MAC地址不应该是这个默认路由的MAC地址吗？？？？？？？？？？？？？？？？？？？？？？**

  ![227](/image/227.png)

- **使用隧道方式传输网络包。**

  BAS将接收到的ATM信元还原为原始的包，然后去掉MAC头部和PPPoE头部，添加隧道专用头部，然后发到隧道出口的专用路由器，在这里，隧道头部被去掉，IP包被取出，并转发到互联网内部网络运营商的路由器上。



**为什么要再经过一个DSLAM设备？？、**



![200](/image/200.png)





## 5.2 光纤接入网（FTTH）

**单模光纤：**纤芯的直径为8~10 μm，相位一致，只能传导一条光线，信号的失真比较小。

**多模光纤：**纤芯的直径为50或者62.5 μm，相位一致，可以有多条不同入射角的光线同时传导，但每条光线入射角不同，到达接收端的时间可能不同，信号宽度被拉伸，失真比较大。

**FTTH主要使用单模光纤。**



### 5.2.1 直连方式

![2141](/image/2141.png)

包从互联网接入路由器发送出去，到达**光纤收发器**，它将电信号转换成光信号，通过光纤发送出去。然后**多路光纤收发器**将光信号转换为电信号，**BAS**端口接收后，将包转发到互联网内部。

### 5.2.2 分路方式

![2142](/image/2142.png)

包从互联网接入路由器发送出去，到达**ONU**（类似于ONU），它将电信号转换成光信号，通过光纤发送出去。然后**OLT**，将光信号转换为电信号，**BAS**端口接收后，将包转发到互联网内部。

多个用户同时收发网络包时信号会在分光器上碰撞，为了避免这一后果，OLT会调整信号发送时机，并向ONU下发指令，ONU根据OLT的指令来发送数据。

## 5.2 接入网将网络包传递到了互联网内部的网络运营商

现在网络包已经到达互联网内部的网络运营商的路由器上了，然后网络包会从这里进入互联网内部。

### 5.2.1 网络包首先进入POP

POP：运营商为用户接入互联网提供的接入点。

> 专线不需要用户认证和下发配置。

![235](/image/235.png)

![245](/image/233.png)

### 5.2.2 通过POP路由器转发到服务器端的局域网

网络数据包到达POP路由器后，会查看POP路由器的路由表，如果Web服务器与客户端是连接在一个运营商中的，则路由表中应该有转发的目标地址。然后将包转发出去。如果Web服务器与客户端不是连接在一个运营商中，则网络包需要先转发到服务器所在的运营商（运营商的路由器在和其他运营商的路由器交换路由信息，BGP 边界网关协议），然后再接着转发。

通过IX可以连接所有运营商，以便运营商们交换数据。IX的核心是具有大量高速的以太网端口的二层交换机，将各个网络运营商的路由器连接到IX核心交换机上，当要通过IX发送数据的时候，IX交换机会先通过ARP查询下一跳路由的MAC地址，然后再发送。



![245](/image/245.png)

# 6.网络包到达服务器端的局域网

网络包在进入互联网之后，通过通信线路和运营商网络到达服务器pop端，接着通过电话局、接入网到达服务器端的局域网部分。网络包会通过局域网中的防火墙、缓存服务器、负载均衡器。

## 6.1 包先经过防火墙

**防火墙的作用：**只允许发往指定服务器的指定应用程序的网络包通过，屏蔽其他不允许通过的包。实现防火墙的方式主要有包过滤、应用层网关、电路层网关，现在主要使用的是包过滤方式。

包过滤方式的防火墙同接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、控制位来判断是否允许这个网络包通过。比如下图，如果不想让web服务器访问互联网，即设置为第二行，TCP建立连接，发送的包中TCP控制位为SYN=1，ACK=0，就将这个包禁止，TCP连接操作就失败了。也要通过端口号来限定只允许访问这个端口的应用程序。除此之外，包过滤方式的防火墙还有地址转换的功能。

![259](/image/259.png)



## 6.2 根据不同的分担负载的方式，将网络包发送到不同的服务器上

### 6.2.1 使用负载均衡器来分担负载

当服务器的访问量上升时，一台服务器难以维持这样的强度，因此需要负载均衡器通过将请求分配给多台功能相同的Web服务器来平衡负载。

**过程：**首先用负载均衡器的IP地址代替Web服务器的实际IP地址注册到DNS服务器上，这样当客户端根据服务器的域名向DNS服务器上查询IP地址的时候，就会返回负载均衡器的IP地址。然后将请求发送到负载均衡器上。

负载均衡器再判断将请求转发到哪台Web服务器上。（代理）

- **操作跨多个页面**

  即多次请求都要访问同一个Web服务器。因为 HTTP 是无状态的连接，当会话结束后，在下一次会话中，负载均衡器并不知道和上一次的是否是同一个用户，而且也并不会自动维护用户的上下文。所以为了识别用户，服务端（负载均衡器）给每个登录用户生成一个唯一标识(session_id)，每一个 session_id 和一个session 值绑定在一起，这个值是用户信息加密后的字符串。第一次创建 session 的时候，服务端会在 HTTP 响应中告诉客户端 session_id 并存储在 cookie 字段中，浏览器会提取出这个值，然后以key：value的形式将这个值存储在本地，浏览器后续每次针对该网站的所有请求都会加上这个 session_id，每次服务端收到请求后，就能根据这个 session_id 来确定用户是谁，从而就可以将多次请求转发到同一个Web服务器上。

- **操作没有跨多个页面**

  根据Web服务器的负载状况来进行判断。负载均衡器可以定期查询服务器的CPU、内存使用率等性能。或者发送网络包，判断返回网络包的时间长短。或者查询根据事先设置的服务器的性能指数。

### 6.2.2 使用代理服务器来分担负载

现在一般都省略"服务器"这三个字，直接称为正向代理、反向代理、透明代理，其实他们就是服务器。

#### 6.2.2.1 正向代理

正向代理的作用：实现防火墙、缓存。

实现防火墙：代理在转发的过程中可以查看请求消息的内容，因此可以根据内容判断是否允许访问某服务器，从而实现过滤。

**要点：**使用正向代理，需要在浏览器的设置端口的代理服务器中填写正向代理的IP地址，这样浏览器在发送请求时会直接忽略URL中的域名，而将请求发给正向代理。请求行中的URI是整个URL的内容（网址）。请求到达正向代理时，会根据URI将请求转发给对应的Web服务器。

#### 6.2.2.2 反向代理

采用在服务端的缓冲服务器的这种方式就是**反向代理**。

缓存服务器是一台通过代理机制对数据进行缓存的服务器。代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能。它可以将Web服务器返回的数据保存在磁盘中，并可以代替Web服务器将磁盘中的数据返回给客户端。

**过程：**首先用缓存服务器的IP地址代替Web服务器的实际IP地址注册到DNS服务器上，这样当客户端根据服务器的域名向DNS服务器上查询IP地址的时候，就会返回缓存服务器的IP地址。然后将请求发送到缓存服务器上。（TCP连接也是与缓存服务器建立的连接）。然后缓存服务器会查看请求消息的内容，看缓存中是否有请求的结果数据。

如果磁盘中没有数据，则缓存服务器将HTTP消息头中加上Via字段（表示该请求经过了缓存服务器），并且根据请求行的URI，判断将这个HTTP请求转发给哪个Web服务器。收到Web服务器的响应后，也会在响应消息头中加上Via字段，并将响应消息保存在缓存中，记录保存的时间。然后将响应消息转发给客户端。

如果磁盘中有数据，则缓存服务器会将HTTP消息头中加上If-Modified-Since头部（上次保存的时间），将消息转发给Web服务器，询问用户请求的数据是否已经变化，Web服务器会查询一下最近更新时间，没变化就返回一个没变化的响应，反之，和没有命中缓存的步骤是一样的。

> 如果一个缓存服务器对应多个Web服务器时，在缓存服务器中会设置当URI为**时，将请求转发给××（域名）。即将URI中的目录名与Web服务器进行关联。此时缓存服务器相当于客户端，Web服务器相当于服务端，也要经历先创建套接字，建立连接等步骤。如果一个缓存服务器对应一个Web服务器的话，就直接转发就行了。

![272](/image/272.png)

#### 6.2.2.3 透明代理

**定义：**利用缓存服务器判断转发目标，这个不用查询之前设置的URI与Web服务器的对应关系，而是直接查看请求消息的IP头部中的接收方IP地址，然后将请求转发到这个IP地址。

透明代理被放在从浏览器到Web服务器的路径中，当消息经过时首先经过透明代理。这个请求是被粗暴拦截的，而不是像反向代理那样直接将请求发送到缓存服务器上。

### 6.2.3 利用内容分发服务来分担负载

内容分发服务：一些专门的厂商来部署缓存服务器，并租借给Web服务器运营者，可以被Web服务器控制，这种服务称为内容分发服务。

它和反向代理不一样的地方是：内容分发服务是将缓存服务器**部署在互联网**中，这样可以有效减少互联网中的流量。即请求不必到达Web服务器端。

**过程：      1.**记录缓存服务器IP地址的DNS服务器上保存有路由表，这个路由表记了不同缓存服务器部署地点的路由器的路由信息。通过将缓存服务器的IP地址替换Web服务器的IP地址注册到DNS服务器上，当浏览器查询客户端DNS服务器来查找接收方的IP地址的时候，DNS服务器会首先根据路由信息估算他们到客户端DNS服务器的距离，选择最短的。        **2.**重定向服务器。通过将重定向服务器的IP地址替换Web服务器的IP地址注册到DNS服务器上，当请求到达重定向服务器时，它根据路由信息估算缓存服务器到客户端（知道发送方IP地址）的距离 ，选择最近的，通过将缓存服务器的IP地址填到请求头的Location字段返回响应。

Web服务器在原始数据发生更新时，就会立即通知缓存服务器。

# 7.请求到达Web服务器

当Web服务器前面的缓存服务器、负载均衡器的缓存中都没有请求对应的响应数据时，这时需要将请求转发给Web服务器。

## 7.1 服务器的初始化

当服务器程序启动并读取配置文件完成初始化操作后，就会进入**等待连接模块**，在这个模块中，协议栈调用socket创建套接字，然后调用bind，将端口号写入套接字中（描述符标识唯一的套接字，后面的交互中就直接使用描述符就可以了），然后调用**listen**向套接字中写入等待连接的暂停状态这一控制信息，这时套接字就等待客户端的网络包。协议栈调用accept，一旦客户端的包到达，就开始连接操作，没有包到达，就处于暂停状态。

当客户端发起连接时，这个模块就会恢复运行，连接结束后，套接字已经连接好了，然后等待连接模块就会复制一个套接字副本给客户端通信模块，启动客户端通信模块，然后让客户端连接到这个新的副本套接字上，就由客户端通信模块与客户端通信了。



![301](/image/301.png)



## 7.2 服务器接收处理网络包

当客户端发送的网络包到达服务器后，首先经过服务器端的网卡，MAC模块将电信号或光信号转化为0和1这样的数字信息，然后检验FCS，没有错就存入网卡的缓冲区中。此时网卡会产生中断，CPU就来到这个任务中，调用网卡驱动程序，它根据MAC头部的以太类型（0800 -> IP协议），调用处理该协议的软件（TCP/IP协议栈）。进入协议栈后，首先IP模块运行，确认包是发给自己的，然后检查是否有分片，如果有，则将包存到内存中，等到分片全部到达再组装还原为原始包，然后根据IP头部的协议号字段（06），将包转交给对应模块（TCP模块）。

> ---------------------------------三次握手------------------------------
>
> 如果是<u>连接包</u>。。TCP头部的控制位SYN=1说明是连接包，则TCP模块会检查接收方指定的端口号上是否有等待连接的套接字，**如果有，则启动客户端通信模块，并为这个套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值（序号表示是从第几个字节开始发送的）、窗口大小（发送方一次发送多少字节）信息写入进去**，并分配发送缓冲区send buffer和接收缓冲区recv buffer的内存空间，然后生成确认号ACK，窗口大小（接受缓冲区的大小），用这些信息生成一个新的TCP头部，发送给客户端。
>
> 要确定某个套接字需要  服务器端IP地址和端口号，客户端IP地址和端口号。

**收到数据包时，**TCP模块会根据发送方IP地址，端口号，接收方IP地址，端口号找到对应套接字，然后将接收到的数据放入recv buffer。并发送ACK号（一共接收了多少字节数据）和更新窗口大小。

![94](/image/94.png)

## 7.3 服务器发送响应信息

服务器程序的客户端通信模块调用read来获取接收到的数据，然后根据HTTP请求行中的URI，在服务器虚拟目录中找到对应关系，再将虚拟目录映射到服务器磁盘上的目录，如果URI指定的是图片或HTML文档，则直接找到响应数据，生成响应消息，协议栈调用write返回给客户端。如果URI指定的是一个程序文件，则需要Web服务器委托OS运行这个程序，获取到数据后再返回给Web服务器。

## 7.4 客户端接收响应消息并显示到页面上

浏览器接收响应数据包，根据Content-Type定义的数据类型，判断响应消息中的数据属于哪种类型，然后浏览器向操作系统发出指令，由操作系统来完成按照不同的方法将数据显示在页面上。

![324](/image/324.png)

## 7.5 断开连接

谁先断开都可以，但一般是服务器先断开。服务器调用Socket库中的close函数，四次挥手，删除对应套接字。

**---------------------------------四次挥手--------------------------------**



完结撒花 ✿✿ヽ(°▽°)ノ✿

